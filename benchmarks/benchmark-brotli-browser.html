<!DOCTYPE html>
<html>
<head>
    <title>Brotli SIMD Benchmark</title>
    <style>
        body { font-family: monospace; background: #1a1a2e; color: #e0e0e0; padding: 40px; }
        h1 { color: #00d9ff; }
        pre { background: #0f0f1a; padding: 20px; border-radius: 8px; white-space: pre-wrap; }
        button { background: #00d9ff; color: #0f0f1a; border: none; padding: 12px 24px; 
                 border-radius: 4px; cursor: pointer; font-size: 16px; margin: 10px 5px; }
        button:hover { background: #00b8d4; }
    </style>
</head>
<body>
    <h1>ðŸ”¬ Brotli SIMD vs Base Benchmark</h1>
    <button onclick="runBenchmark(100*1024)">Run 100KB</button>
    <button onclick="runBenchmark(1024*1024)">Run 1MB</button>
    <pre id="output">Loading modules...</pre>

    <script type="module">
        const output = document.getElementById('output');
        
        async function loadWasm(url) {
            const res = await fetch(url);
            const bytes = await res.arrayBuffer();
            const { instance } = await WebAssembly.instantiate(bytes, {});
            return instance;
        }
        
        function compress(instance, data, abi) {
            const exports = instance.exports;
            const inLen = data.length;
            const outLen = inLen + 1024;
            
            const inPtr = exports.alloc_bytes(inLen);
            const outPtr = exports.alloc_bytes(outLen);
            
            let memory = new Uint8Array(exports.memory.buffer);
            memory.set(data, inPtr);
            
            const written = exports[abi](inPtr, inLen, outPtr, outLen);
            
            memory = new Uint8Array(exports.memory.buffer);
            const result = memory.slice(outPtr, outPtr + written);
            exports.free_bytes(inPtr, inLen);
            exports.free_bytes(outPtr, outLen);
            
            return result;
        }
        
        function benchmark(fn, runs = 10) {
            for (let i = 0; i < 3; i++) fn();
            
            const times = [];
            const iterations = 3; // Brotli is slower, use fewer iterations
            for (let i = 0; i < runs; i++) {
                const start = performance.now();
                for (let j = 0; j < iterations; j++) fn();
                times.push((performance.now() - start) / iterations);
            }
            
            times.sort((a, b) => a - b);
            return times[Math.floor(times.length / 2)];
        }
        
        function generateData(size) {
            const pattern = '{"id":12345,"name":"test","email":"user@example.com","values":[1,2,3]}';
            const data = new Uint8Array(size);
            for (let i = 0; i < size; i++) data[i] = pattern.charCodeAt(i % pattern.length);
            return data;
        }
        
        let baseInstance, simdInstance;
        
        async function init() {
            output.textContent = 'Loading Brotli Base WASM...\n';
            baseInstance = await loadWasm('../js/brotli/dist/wasm/brotli.base.wasm');
            output.textContent += 'Loading Brotli SIMD WASM...\n';
            simdInstance = await loadWasm('../js/brotli/dist/wasm/brotli.simd.wasm');
            output.textContent += 'Ready! Click a button to benchmark.\n';
        }
        
        window.runBenchmark = async function(size) {
            if (!baseInstance || !simdInstance) {
                output.textContent = 'Still loading...';
                return;
            }
            
            const data = generateData(size);
            const sizeMB = size / 1024 / 1024;
            const sizeLabel = size >= 1024*1024 ? `${size/1024/1024} MB` : `${size/1024} KB`;
            
            output.textContent = `\nðŸ”¬ Brotli SIMD vs Base Benchmark (${sizeLabel})\n`;
            output.textContent += '='.repeat(70) + '\n\n';
            
            const levels = [1, 4, 6, 9];
            
            output.textContent += `| Level | Base (ms) | SIMD (ms) | Base Speed  | SIMD Speed  | Speedup | Ratio  |\n`;
            output.textContent += `|-------|-----------|-----------|-------------|-------------|---------|--------|\n`;
            
            for (const level of levels) {
                output.textContent += `Testing Level ${level}...\n`;
                await new Promise(r => setTimeout(r, 10));
                
                const abi = `compress_brotli_level_${level}`;
                
                const baseTime = benchmark(() => compress(baseInstance, data, abi));
                const baseResult = compress(baseInstance, data, abi);
                
                const simdTime = benchmark(() => compress(simdInstance, data, abi));
                const simdResult = compress(simdInstance, data, abi);
                
                const baseSpeed = (sizeMB / (baseTime / 1000)).toFixed(0);
                const simdSpeed = (sizeMB / (simdTime / 1000)).toFixed(0);
                const speedup = (baseTime / simdTime).toFixed(2);
                const ratio = (baseResult.length / data.length * 100).toFixed(1);
                
                // Clear testing line and add result
                const lines = output.textContent.split('\n');
                lines.pop(); lines.pop();
                output.textContent = lines.join('\n') + '\n';
                
                const speedupStr = speedup > 1.1 ? `${speedup}x ðŸš€` : `${speedup}x`;
                output.textContent += `|   ${level}   | ${baseTime.toFixed(2).padStart(9)} | ${simdTime.toFixed(2).padStart(9)} | ${(baseSpeed + ' MB/s').padStart(11)} | ${(simdSpeed + ' MB/s').padStart(11)} | ${speedupStr.padStart(7)} | ${ratio}%   |\n`;
            }
            
            output.textContent += '\nâœ… Complete!\n';
            output.textContent += '\nNote: Brotli SIMD gains come from rust-brotli fork with SIMD optimizations.\n';
        };
        
        init();
    </script>
</body>
</html>

